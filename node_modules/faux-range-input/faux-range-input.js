;(function() {
  'use strict';

  var BOOLEANS_AS_STRINGS = {true: true, false: false};

  function firstDefined(one, another) {
    return one !== null && one !== undefined && one !== '' ? one : another;
  }

  function create(tagAndClasses, parent) {
    tagAndClasses = tagAndClasses.split('.');

    var tag = tagAndClasses.shift();
    var element = document.createElement(tag);

    var classes = tagAndClasses;
    if (classes.length > 0) element.className = classes.join(' ');

    if (parent) parent.appendChild(element);

    return element;
  }

  function setEvents(el, addOrRemove, events) {
    for (var eventName in events) {
      var handler = events[eventName];
      el[addOrRemove + 'EventListener'](eventName, handler, false);
    }
  }

  function FauxRangeInput(input) {
    Object.keys(this.constructor.prototype).forEach(function(property) {
      if (property.match(/^_on/)) this[property] = this[property].bind(this);
    }, this);

    if (typeof input === 'string') input = document.querySelector(input);

    this.el = create('span.faux-range-input');
    this.fill = create('span.faux-range-fill', this.el);
    this.track = create('span.faux-range-track', this.el);
    this.ticksContainer = create('span.faux-range-ticks', this.track);
    this.thumb = create('span.faux-range-thumb', this.track);

    this.input = input || create('input');
    this.input.setAttribute('data-is-faux', true);
    this.thumb.tabIndex = this.input.tabIndex;

    if (this.input.parentNode) this.input.parentNode.insertBefore(this.el, this.input);
    this.el.appendChild(this.input);

    setEvents(this.el, 'add', {
      mousedown: this._onStart,
      touchstart: this._onStart,
      keydown: this._onKeyDown
    });

    this.name = this.input.name;
    this.min = firstDefined(this.input.getAttribute('min'), 0);
    this.max = firstDefined(this.input.getAttribute('max'), 100);
    this.step = firstDefined(this.input.getAttribute('step'), 1);
    this.value = firstDefined(this.input.getAttribute('value'), ((this.max - this.min) / 2) + this.min);

    this.snap = firstDefined(this.input.getAttribute('data-snap'), true);
    this.ticks = firstDefined(this.input.getAttribute('data-ticks'), false);

    FauxRangeInput.instances.push(this);
  }

  FauxRangeInput.instances = [];

  FauxRangeInput.pollEvery = 500;

  FauxRangeInput.find = function(root) {
    if (!root || !('querySelectorAll' in root)) root = document;

    return Array.prototype.map.call(root.querySelectorAll('input[type="range"]'), function(input) {
      if (input.hasAttribute('data-is-faux')) {
        return;
      }

      return new FauxRangeInput(input);
    }, this);
  };

  FauxRangeInput.syncAll = function() {
    FauxRangeInput.instances.forEach(function(instance) {
      ['min', 'max', 'step', 'value', 'disabled'].forEach(function(property) {
        instance[property] = instance.input[property];
      });
    });
  };

  FauxRangeInput.poll = function() {
    if (!FauxRangeInput.pollEvery) {
      return;
    }

    FauxRangeInput.syncAll();
    setTimeout(FauxRangeInput.poll, FauxRangeInput.pollEvery);
  };

  Object.defineProperty(FauxRangeInput.prototype, 'name', {
    set: function(value) {
      this.input.name = value;
    },

    get: function() {
      return this.input.name;
    }
  });

  ['min', 'max', 'step'].forEach(function(property) {
    Object.defineProperty(FauxRangeInput.prototype, property, {
      set: function(value) {
        this.input[property] = value;
        this._drawTicks();
      },

      get: function() {
        return parseFloat(this.input[property]);
      }
    });
  });

  Object.defineProperty(FauxRangeInput.prototype, 'value', {
    set: function(value) {
      var oldValue = this.value;

      value = Math.min(Math.max(parseFloat(value), this.min), this.max);

      if (this.snap) {
        value = (this.step * (Math.round((value - this.min) / this.step))) + this.min;
      }

      this.input.value = value;
      this._render();
      if (value !== oldValue) this._emit('change');
    },

    get: function() {
      return parseFloat(this.input.value);
    }
  });

  Object.defineProperty(FauxRangeInput.prototype, 'ticks', {
    set: function(value) {
      var asBoolean = BOOLEANS_AS_STRINGS[value];
      value = asBoolean !== undefined ? asBoolean : parseFloat(value);
      this['~ticks'] = value;
      this._drawTicks();
    },

    get: function() {
      return this['~ticks'];
    }
  });

  Object.defineProperty(FauxRangeInput.prototype, 'snap', {
    set: function(value) {
      value = !!value
      this['~snap'] = value;
    },

    get: function() {
      return this['~snap'];
    }
  });

  Object.defineProperty(FauxRangeInput.prototype, 'disabled', {
    set: function(value) {
      this.input.disabled = !!value;
      if (this.input.disabled) {
        this.el.setAttribute('disabled', true);
      } else {
        this.el.removeAttribute('disabled');
      }
    },

    get: function() {
      return this.input.disabled;
    }
  });

  FauxRangeInput.prototype._left = NaN;
  FauxRangeInput.prototype._width = NaN;

  FauxRangeInput.prototype._onStart = function(e) {
    e.preventDefault();

    setEvents(document, 'add', {
      mousemove: this._onMove,
      touchmove: this._onMove,
      mouseup: this._onEnd,
      touchend: this._onEnd
    });

    var coords = this.el.getBoundingClientRect();
    this._left = coords.left;
    this._width = coords.right - coords.left;

    this._onMove(e);
    setTimeout(this.thumb.focus.bind(this.thumb));
  };

  FauxRangeInput.prototype._onMove = function(e) {
    var percent = (e.pageX - pageXOffset - this._left) / this._width;
    this.value = (percent * (this.max - this.min)) + this.min;
  };

  FauxRangeInput.prototype._onEnd = function(e) {
    setEvents(document, 'remove', {
      mousemove: this._onMove,
      touchmove: this._onMove,
      mouseup: this._onEnd,
      touchend: this._onEnd
    });
  };

  FauxRangeInput.prototype._onKeyDown = function(e) {
    switch(e.which) {
      case 37: // Left
      case 40: // Down
        this.value -= this.step;
        break;
      case 39: // Right
      case 38: // Up
        this.value += this.step;
        break;
    }
  };

  FauxRangeInput.prototype._emit = function(eventName) {
    if ('dispatchEvent' in this.input) {
      var event = document.createEvent('HTMLEvents');
      event.initEvent('change', true, true);
      this.input.dispatchEvent(event);
    } else if ('fireEvent' in this.input) {
      this.input.fireEvent('on' + eventName);
    }
  };

  FauxRangeInput.prototype._drawTicks = function() {
    while (this.ticksContainer.children.length > 0) {
      this.ticksContainer.removeChild(this.ticksContainer.children[0]);
    }

    if (!this.ticks) return;

    var ticks = 0;
    if (this.ticks === true) {
      ticks = Math.ceil(((this.max - this.min) / this.step)  + 1);
    } else {
      ticks = parseFloat(this.ticks) || 0;
    }

    for (var i = 0; i < ticks; i++) {
      var tick = create('span.faux-range-tick', this.ticksContainer);
      tick.style.left = ((i / (ticks - 1)) * 100).toString() + '%';
    }
  };

  FauxRangeInput.prototype._render = function() {
    this.thumb.style.left = (((this.value - this.min) / (this.max - this.min)) * 100).toString() + '%';
    this.fill.style.width = (((this.value - this.min) / (this.max - this.min)) * 100).toString() + '%';
  };

  FauxRangeInput.prototype.destroy = function() {
    setEvents(this.el, 'remove', {
      mousedown: this._onStart,
      touchstart: this._onStart,
      keydown: this._onKeyDown
    });

    setEvents(document, 'remove', {
      mousemove: this._onMove,
      touchmove: this._onMove,
      mouseup: this._onEnd,
      touchend: this._onEnd
    });

    this._emit('destroy');

    if (this.el.parentNode) {
      this.el.parentNode.removeChild(this.el);
    }

    FauxRangeInput.instances.splice(FauxRangeInput.instances.indexOf(this), 1);
  };

  if (typeof FAUX_RANGE_INPUT_DONT_AUTO_FIND === 'undefined' || !FAUX_RANGE_INPUT_DONT_AUTO_FIND) {
    addEventListener('DOMContentLoaded', FauxRangeInput.find, false);
  }

  if (typeof FAUX_RANGE_INPUT_DONT_POLL === 'undefined' || !FAUX_RANGE_INPUT_DONT_POLL) {
    addEventListener('DOMContentLoaded', FauxRangeInput.poll.bind(FauxRangeInput), false);
  }

  window.FauxRangeInput = FauxRangeInput;
  if (typeof module !== 'undefined') module.exports = FauxRangeInput;
  if (typeof define !== 'undefined') define(function() {return FauxRangeInput;});
}.call());
