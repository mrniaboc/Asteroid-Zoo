// Generated by CoffeeScript 1.6.3
(function() {
  var BACKSPACE, BaseClass, CASE_SENSITIVE_ATTRIBUTES, DELETE, IE_HACK_ID, Mark, MarkingSurface, NAMESPACES, NON_ATTRIBUTE_PROPERTIES, POINTER_EVENTS, PREFIXED_GRAB, PREFIXED_GRABBING, SVG, TAB, Tool, ToolControls, defs, elements, filters, insertStyle, name, removeFrom, toggleClass, _ref, _ref1,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty,
    __slice = [].slice,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  removeFrom = function(item, array) {
    while (__indexOf.call(array, item) >= 0) {
      array.splice(array.indexOf(item), 1);
    }
    return null;
  };

  toggleClass = function(element, className, condition) {
    var classList, contained;
    classList = element.className.match(/\S+/g);
    if (classList == null) {
      classList = [];
    }
    contained = __indexOf.call(classList, className) >= 0;
    if (condition == null) {
      condition = !contained;
    }
    condition = !!condition;
    if (!contained && condition === true) {
      classList.push(className);
    }
    if (contained && condition === false) {
      removeFrom(className, classList);
    }
    element.className = classList.join(' ');
    return null;
  };

  IE_HACK_ID = 'marking-surface-element-that-only-exists-to-please-ie';

  insertStyle = function(id, styleContent) {
    var ieHackElement;
    document.body.insertAdjacentHTML('afterBegin', "<span id=\"" + IE_HACK_ID + "\"></span>\n<style id=\"" + id + "\">" + styleContent + "</style>");
    ieHackElement = document.getElementById(IE_HACK_ID);
    ieHackElement.parentNode.removeChild(ieHackElement);
    return document.getElementById(id);
  };

  BaseClass = (function() {
    BaseClass.prototype._events = null;

    function BaseClass(params) {
      var property, value;
      if (params == null) {
        params = {};
      }
      for (property in params) {
        if (!__hasProp.call(params, property)) continue;
        value = params[property];
        if (property in this) {
          this[property] = value;
        }
      }
      this._events = {};
    }

    BaseClass.prototype.on = function(eventName, handler) {
      var _base;
      if ((_base = this._events)[eventName] == null) {
        _base[eventName] = [];
      }
      this._events[eventName].push(handler);
      return null;
    };

    BaseClass.prototype.trigger = function(eventName, args) {
      var handler, _base, _i, _len, _ref;
      if (args == null) {
        args = [];
      }
      if ((_base = this._events)[eventName] == null) {
        _base[eventName] = [];
      }
      _ref = this._events[eventName];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        handler = _ref[_i];
        handler.apply(this, args);
      }
      return null;
    };

    BaseClass.prototype.off = function(eventName, handler) {
      var handlerList, property;
      if (eventName != null) {
        handlerList = this._events[eventName] || [];
        if (handler != null) {
          removeFrom(handler, handlerList);
        } else {
          handlerList.splice(0);
        }
      } else {
        for (property in this._events) {
          delete this._events[property];
        }
      }
      return null;
    };

    BaseClass.prototype.destroy = function() {
      this.trigger('destroy');
      this.off();
      return null;
    };

    return BaseClass;

  })();

  NAMESPACES = {
    svg: 'http://www.w3.org/2000/svg',
    xlink: 'http://www.w3.org/1999/xlink'
  };

  CASE_SENSITIVE_ATTRIBUTES = ['viewBox', 'preserveAspectRatio'];

  NON_ATTRIBUTE_PROPERTIES = ['textContent'];

  filters = {
    shadow: [
      {
        element: 'feOffset',
        attributes: {
          "in": 'SourceAlpha',
          dx: 0.5,
          dy: 1.5,
          result: 'offOut'
        }
      }, {
        element: 'feBlend',
        attributes: {
          "in": 'SourceGraphic',
          in2: 'offOut'
        }
      }
    ]
  };

  SVG = (function() {
    SVG.prototype.el = null;

    function SVG(tagName, attributes) {
      var classes, namespace, _i, _ref, _ref1, _ref2;
      if (typeof tagName !== 'string') {
        _ref = ['svg', tagName], tagName = _ref[0], attributes = _ref[1];
      }
      _ref1 = tagName.split('.'), tagName = _ref1[0], classes = 2 <= _ref1.length ? __slice.call(_ref1, 1) : [];
      classes = classes.join(' ');
      _ref2 = tagName.split(':'), namespace = 2 <= _ref2.length ? __slice.call(_ref2, 0, _i = _ref2.length - 1) : (_i = 0, []), tagName = _ref2[_i++];
      namespace = namespace.join('');
      namespace || (namespace = 'svg');
      this.el = document.createElementNS(NAMESPACES[namespace] || null, tagName);
      if (classes) {
        this.attr('class', classes);
      }
      this.attr(attributes);
    }

    SVG.prototype.attr = function(attribute, value) {
      var attributes, namespace, _i, _ref;
      if (typeof attribute === 'string') {
        if (!(__indexOf.call(CASE_SENSITIVE_ATTRIBUTES, attribute) >= 0 || __indexOf.call(NON_ATTRIBUTE_PROPERTIES, attribute) >= 0)) {
          attribute = (attribute.replace(/([A-Z])/g, '-$1')).toLowerCase();
        }
        _ref = attribute.split(':'), namespace = 2 <= _ref.length ? __slice.call(_ref, 0, _i = _ref.length - 1) : (_i = 0, []), attribute = _ref[_i++];
        namespace = namespace.join('');
        if (value != null) {
          if (__indexOf.call(NON_ATTRIBUTE_PROPERTIES, attribute) >= 0) {
            this.el[attribute] = value;
          } else {
            this.el.setAttributeNS(NAMESPACES[namespace] || null, attribute, value);
          }
        } else {
          if (__indexOf.call(NON_ATTRIBUTE_PROPERTIES, attribute) >= 0) {
            return this.el[attribute];
          } else {
            return this.el.getAttributeNS(NAMESPACES[namespace] || null, attribute);
          }
        }
      } else {
        attributes = attribute;
        for (attribute in attributes) {
          value = attributes[attribute];
          this.attr(attribute, value);
        }
      }
      return null;
    };

    SVG.prototype.filter = function(name) {
      return this.attr('filter', name != null ? "url(#marking-surface-filter-" + name + ")" : '');
    };

    SVG.prototype.addShape = function(tagName, attributes) {
      var shape;
      shape = new this.constructor(tagName, attributes);
      this.el.appendChild(shape.el);
      return shape;
    };

    SVG.prototype.toFront = function() {
      this.el.parentNode.appendChild(this.el);
      return null;
    };

    SVG.prototype.remove = function() {
      this.el.parentNode.removeChild(this.el);
      return null;
    };

    return SVG;

  })();

  SVG.filtersContainer = new SVG({
    id: 'marking-surface-filters-container',
    width: 0,
    height: 0,
    style: 'bottom: 0; position: absolute; right: 0;'
  });

  defs = SVG.filtersContainer.addShape('defs');

  SVG.registerFilter = function(name, elements) {
    var attributes, element, filter, _i, _len, _ref;
    filters[name] = elements;
    filter = defs.addShape('filter', {
      id: "marking-surface-filter-" + name
    });
    for (_i = 0, _len = elements.length; _i < _len; _i++) {
      _ref = elements[_i], element = _ref.element, attributes = _ref.attributes;
      filter.addShape(element, attributes);
    }
    return null;
  };

  for (name in filters) {
    elements = filters[name];
    SVG.registerFilter(name, elements);
  }

  document.body.appendChild(SVG.filtersContainer.el);

  Mark = (function(_super) {
    __extends(Mark, _super);

    function Mark() {
      _ref = Mark.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    Mark.prototype.set = function(property, value, _arg) {
      var fromMany, properties, setValue, setter;
      fromMany = (_arg != null ? _arg : {}).fromMany;
      if (typeof property === 'string') {
        setter = this["set " + property];
        setValue = setter != null ? setter.call(this, value) : value;
        this[property] = setValue;
        this.trigger("change-property", [setValue]);
      } else {
        properties = property;
        for (property in properties) {
          value = properties[property];
          this.set(property, value, {
            fromMany: true
          });
        }
      }
      if (!fromMany) {
        this.trigger('change', [property, value]);
      }
      return null;
    };

    Mark.prototype.toJSON = function() {
      var property, result, value;
      result = {};
      for (property in this) {
        value = this[property];
        if ((property.charAt(0)) === '_') {
          continue;
        }
        if (typeof value === 'function') {
          continue;
        }
        result[property] = this[property];
      }
      return result;
    };

    return Mark;

  })(BaseClass);

  ToolControls = (function(_super) {
    __extends(ToolControls, _super);

    ToolControls.prototype.tool = null;

    ToolControls.prototype.tagName = 'div';

    ToolControls.prototype.className = 'marking-tool-controls';

    ToolControls.prototype.template = '';

    ToolControls.prototype.isOpen = false;

    function ToolControls() {
      this.onToolDestroy = __bind(this.onToolDestroy, this);
      this.onToolDeselect = __bind(this.onToolDeselect, this);
      this.onMarkChange = __bind(this.onMarkChange, this);
      this.onToolSelect = __bind(this.onToolSelect, this);
      this.onMouseDown = __bind(this.onMouseDown, this);
      this.onToolInitialRelease = __bind(this.onToolInitialRelease, this);
      ToolControls.__super__.constructor.apply(this, arguments);
      this.el = document.createElement(this.tagName);
      toggleClass(this.el, this.constructor.prototype.className, true);
      toggleClass(this.el, this.className, true);
      this.el.innerHTML = this.template;
      this.el.addEventListener('mousedown', this.onMouseDown, false);
      this.tool.on('initial-release', this.onToolInitialRelease);
      this.tool.on('select', this.onToolSelect);
      this.tool.mark.on('change', this.onMarkChange);
      this.tool.on('deselect', this.onToolDeselect);
      this.tool.on('destroy', this.onToolDestroy);
      this.tool.surface.el.appendChild(this.el);
    }

    ToolControls.prototype.onToolInitialRelease = function() {
      toggleClass(this.el, 'tool-complete', this.tool.isComplete());
      return null;
    };

    ToolControls.prototype.onMouseDown = function() {
      if (this.tool.surface.disabled) {
        return;
      }
      this.tool.select();
      return null;
    };

    ToolControls.prototype.onToolSelect = function() {
      toggleClass(this.el, 'tool-selected', true);
      this.el.parentNode.appendChild(this.el);
      if (!this.isOpen) {
        this.open();
      }
      this.isOpen = true;
      return null;
    };

    ToolControls.prototype.onMarkChange = function() {
      this.render.apply(this, arguments);
      return null;
    };

    ToolControls.prototype.onToolDeselect = function() {
      toggleClass(this.el, 'tool-selected', false);
      if (this.isOpen) {
        this.close();
      }
      this.isOpen = false;
      return null;
    };

    ToolControls.prototype.onToolDestroy = function() {
      this.destroy();
      return null;
    };

    ToolControls.prototype.destroy = function() {
      this.el.removeEventListener('mousedown', this.onMouseDown, false);
      this.el.parentNode.removeChild(this.el);
      ToolControls.__super__.destroy.apply(this, arguments);
      return null;
    };

    ToolControls.prototype.moveTo = function(x, y) {
      var height, left, opensDown, opensRight, outOfBounds, panX, panY, top, width, zoomBy, _ref1;
      _ref1 = this.tool.surface, zoomBy = _ref1.zoomBy, panX = _ref1.panX, panY = _ref1.panY;
      width = this.tool.surface.el.clientWidth;
      height = this.tool.surface.el.clientHeight;
      panX *= width - (width / zoomBy);
      panY *= height - (height / zoomBy);
      left = Math.floor((x * zoomBy) - (panX * zoomBy));
      top = Math.floor((y * zoomBy) - (panY * zoomBy));
      this.el.style.left = "" + left + "px";
      this.el.style.top = "" + top + "px";
      opensRight = x < width / 2;
      opensDown = y < height / 2;
      toggleClass(this.el, 'opens-right', opensRight);
      toggleClass(this.el, 'opens-left', !opensRight);
      toggleClass(this.el, 'opens-down', opensDown);
      toggleClass(this.el, 'opens-up', !opensDown);
      outOfBounds = left < 0 || left > width || top < 0 || top > height;
      toggleClass(this.el, 'out-of-bounds', outOfBounds);
      return null;
    };

    ToolControls.prototype.open = function() {};

    ToolControls.prototype.close = function() {};

    ToolControls.prototype.render = function() {};

    return ToolControls;

  })(BaseClass);

  ToolControls.defaultStyle = insertStyle('marking-surface-tool-controls-default-style', '.marking-tool-controls {\n  position: absolute;\n}\n\n.marking-tool-controls.out-of-bounds {\n  display: none\n}');

  POINTER_EVENTS = ['mousedown', 'mouseover', 'mousemove', 'mouseout', 'mouseup', 'touchstart', 'touchmove', 'touchend'];

  _ref1 = 'webkitMatchesSelector' in document.body ? ['-webkit-grab', '-webkit-grabbing'] : 'mozMatchesSelector' in document.body ? ['-moz-grab', '-moz-grabbing'] : ['move', 'move'], PREFIXED_GRAB = _ref1[0], PREFIXED_GRABBING = _ref1[1];

  Tool = (function(_super) {
    __extends(Tool, _super);

    Tool.Mark = Mark;

    Tool.Controls = ToolControls;

    Tool.prototype.cursors = null;

    Tool.prototype.deselectedOpacity = 0.5;

    Tool.prototype.renderFps = 30;

    Tool.prototype.surface = null;

    Tool.prototype.mark = null;

    Tool.prototype.controls = null;

    Tool.prototype.root = null;

    Tool.prototype.group = null;

    Tool.prototype.drags = 0;

    Tool.prototype.renderTimeout = NaN;

    function Tool() {
      this.destroy = __bind(this.destroy, this);
      this.onMarkDestory = __bind(this.onMarkDestory, this);
      this.onMarkChange = __bind(this.onMarkChange, this);
      this.handleEvents = __bind(this.handleEvents, this);
      var eventName, _i, _len;
      Tool.__super__.constructor.apply(this, arguments);
      if (this.mark == null) {
        this.mark = new this.constructor.Mark;
      }
      this.mark.on('change', this.onMarkChange);
      this.mark.on('destroy', this.onMarkDestory);
      this.controls = new this.constructor.Controls({
        tool: this
      });
      this.root = this.surface.addShape('g.marking-tool-root');
      this.group = this.root.addShape('g.marking-tool-group');
      this.group.attr({
        fill: 'transparent',
        stroke: 'transparent',
        strokeWidth: 0
      });
      for (_i = 0, _len = POINTER_EVENTS.length; _i < _len; _i++) {
        eventName = POINTER_EVENTS[_i];
        this.root.el.addEventListener(eventName, this.handleEvents, false);
      }
      this.initialize.apply(this, arguments);
    }

    Tool.prototype.addShape = function() {
      var _ref2;
      return (_ref2 = this.group).addShape.apply(_ref2, arguments);
    };

    Tool.prototype.onInitialClick = function(e) {
      this.trigger('initial-click', [e]);
      return this.onFirstClick(e);
    };

    Tool.prototype.onInitialDrag = function(e) {
      this.trigger('initial-drag', [e]);
      return this.onFirstDrag(e);
    };

    Tool.prototype.onInitialRelease = function(e) {
      this.drags += 1;
      this.trigger('initial-release', [e]);
      return this.onFirstRelease(e);
    };

    Tool.prototype.isComplete = function() {
      return this.drags === 1;
    };

    Tool.prototype.handleEvents = function(e) {
      var endEvent, endHandler, eventName, matchingNames, moveEvent, moveHandler, property, target, value, valueItem, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _results, _results1, _results2,
        _this = this;
      if (this.surface.disabled) {
        return;
      }
      eventName = e.type;
      target = e.target || e.srcElement;
      matchingNames = [];
      for (property in this) {
        if (!__hasProp.call(this, property)) continue;
        value = this[property];
        if ((value != null ? value.el : void 0) === target) {
          matchingNames.push(property);
        } else {
          if (value instanceof Array) {
            for (_i = 0, _len = value.length; _i < _len; _i++) {
              valueItem = value[_i];
              if ((valueItem != null ? valueItem.el : void 0) === target) {
                matchingNames.push(property);
                break;
              }
            }
          }
        }
      }
      if ((_ref2 = this["on " + eventName]) != null) {
        _ref2.call(this, e);
      }
      for (_j = 0, _len1 = matchingNames.length; _j < _len1; _j++) {
        name = matchingNames[_j];
        if ((_ref3 = this["on " + eventName + " " + name]) != null) {
          _ref3.call(this, e);
        }
      }
      switch (eventName) {
        case 'mouseover':
          if (this.surface.el.style.cursor !== PREFIXED_GRABBING) {
            if (this.cursors != null) {
              _results = [];
              for (_k = 0, _len2 = matchingNames.length; _k < _len2; _k++) {
                name = matchingNames[_k];
                if (this.cursors[name] === '*grab') {
                  _results.push(this.surface.el.style.cursor = PREFIXED_GRAB);
                } else {
                  _results.push(this.surface.el.style.cursor = this.cursors[name]);
                }
              }
              return _results;
            }
          }
          break;
        case 'mousemove':
        case 'touchmove':
          if ((_ref4 = this['on *move']) != null) {
            _ref4.call(this, e);
          }
          _results1 = [];
          for (_l = 0, _len3 = matchingNames.length; _l < _len3; _l++) {
            name = matchingNames[_l];
            _results1.push((_ref5 = this["on *move " + name]) != null ? _ref5.call(this, e) : void 0);
          }
          return _results1;
          break;
        case 'mousedown':
        case 'touchstart':
          if (this.surface.el.style.cursor === PREFIXED_GRAB) {
            this.surface.el.style.cursor = PREFIXED_GRABBING;
            document.body.cursor = document.body.cursor;
          }
          e.preventDefault();
          this.select();
          if ((_ref6 = this['on *start']) != null) {
            _ref6.call(this, e);
          }
          moveEvent = eventName === 'mousedown' ? 'mousemove' : 'touchmove';
          endEvent = eventName === 'mousedown' ? 'mouseup' : 'touchend';
          if ('on *drag' in this) {
            this["on *drag"](e);
            moveHandler = function(e) {
              return _this['on *drag'](e);
            };
            endHandler = function() {
              document.removeEventListener(moveEvent, moveHandler, false);
              return document.removeEventListener(endEvent, endHandler, false);
            };
            document.addEventListener(moveEvent, moveHandler, false);
            document.addEventListener(endEvent, endHandler, false);
          }
          _results2 = [];
          for (_m = 0, _len4 = matchingNames.length; _m < _len4; _m++) {
            name = matchingNames[_m];
            _results2.push((function(name) {
              var namedEndHandler, namedMoveHandler, _ref7;
              if ((_ref7 = _this["on *start " + name]) != null) {
                _ref7.call(_this, e);
              }
              if (("on *drag " + name) in _this) {
                _this["on *drag " + name](e);
                namedMoveHandler = function(e) {
                  return _this["on *drag " + name](e);
                };
                namedEndHandler = function() {
                  document.removeEventListener(moveEvent, namedMoveHandler, false);
                  return document.removeEventListener(endEvent, namedEndHandler, false);
                };
                document.addEventListener(moveEvent, namedMoveHandler, false);
                return document.addEventListener(endEvent, namedEndHandler, false);
              }
            })(name));
          }
          return _results2;
          break;
        case 'mouseup':
        case 'touchend':
          if (this.surface.el.style.cursor === PREFIXED_GRABBING) {
            this.surface.el.style.cursor = PREFIXED_GRAB;
          }
          if ((_ref7 = this['on *end']) != null) {
            _ref7.call(this, e);
          }
          return (_ref8 = this["on *end " + name]) != null ? _ref8.call(this, e) : void 0;
        case 'mouseout':
          return this.surface.el.style.cursor = '';
      }
    };

    Tool.prototype.onMarkChange = function() {
      var _this = this;
      if (!isNaN(this.renderTimeout)) {
        return;
      }
      this.render.apply(this, arguments);
      return this.renderTimeout = setTimeout((function() {
        _this.render(arguments);
        return _this.renderTimeout = NaN;
      }), 1000 / this.renderFps);
    };

    Tool.prototype.onMarkDestory = function() {
      this.destroy.apply(this, arguments);
      return null;
    };

    Tool.prototype.select = function() {
      this.root.attr('opacity', 1);
      this.root.toFront();
      this.trigger('select', arguments);
      return null;
    };

    Tool.prototype.deselect = function() {
      this.root.attr('opacity', this.deselectedOpacity);
      this.trigger('deselect', arguments);
      return null;
    };

    Tool.prototype.destroy = function() {
      var eventName, _i, _len;
      this.deselect();
      for (_i = 0, _len = POINTER_EVENTS.length; _i < _len; _i++) {
        eventName = POINTER_EVENTS[_i];
        this.root.el.removeEventListener(eventName, this.handleEvents, false);
      }
      this.root.remove();
      Tool.__super__.destroy.apply(this, arguments);
      return null;
    };

    Tool.prototype.pointerOffset = function() {
      var _ref2;
      return (_ref2 = this.surface).pointerOffset.apply(_ref2, arguments);
    };

    Tool.prototype.initialize = function() {};

    Tool.prototype.onFirstClick = function() {};

    Tool.prototype.onFirstDrag = function() {};

    Tool.prototype.onFirstRelease = function() {};

    Tool.prototype.render = function() {};

    return Tool;

  })(BaseClass);

  BACKSPACE = 8;

  DELETE = 46;

  TAB = 9;

  MarkingSurface = (function(_super) {
    __extends(MarkingSurface, _super);

    MarkingSurface.prototype.tool = Tool;

    MarkingSurface.prototype.tagName = 'div';

    MarkingSurface.prototype.className = 'marking-surface';

    MarkingSurface.prototype.tabIndex = 0;

    MarkingSurface.prototype.svg = null;

    MarkingSurface.prototype.zoomBy = 1;

    MarkingSurface.prototype.zoomSnapTolerance = 0.05;

    MarkingSurface.prototype.panX = 0.5;

    MarkingSurface.prototype.panY = 0.5;

    MarkingSurface.prototype.tools = null;

    MarkingSurface.prototype.selection = null;

    MarkingSurface.prototype.marks = null;

    MarkingSurface.prototype.disabled = false;

    MarkingSurface.prototype.offsetAtLastMousedown = null;

    function MarkingSurface() {
      this.onKeyDown = __bind(this.onKeyDown, this);
      this.onTouchStart = __bind(this.onTouchStart, this);
      this.onRelease = __bind(this.onRelease, this);
      this.onDrag = __bind(this.onDrag, this);
      this.onMouseDown = __bind(this.onMouseDown, this);
      this.onTouchMove = __bind(this.onTouchMove, this);
      this.onMouseMove = __bind(this.onMouseMove, this);
      MarkingSurface.__super__.constructor.apply(this, arguments);
      if (typeof this.el === 'string') {
        this.el = document.querySelectorAll(this.el);
      }
      if (this.el == null) {
        this.el = document.createElement(this.tagName);
      }
      toggleClass(this.el, this.constructor.prototype.className, true);
      toggleClass(this.el, this.className, true);
      this.el.setAttribute('tabindex', this.tabIndex);
      this.el.addEventListener('mousemove', this.onMouseMove, false);
      this.el.addEventListener('touchmove', this.onTouchMove, false);
      this.el.addEventListener('mousedown', this.onMouseDown, false);
      this.el.addEventListener('touchstart', this.onTouchStart, false);
      this.el.addEventListener('keydown', this.onKeyDown, false);
      if (this.svg == null) {
        this.svg = new SVG;
      }
      if (this.svgRoot == null) {
        this.svgRoot = this.svg.addShape('g.svg-root');
      }
      this.el.appendChild(this.svg.el);
      if (this.marks == null) {
        this.marks = [];
      }
      if (this.tools == null) {
        this.tools = [];
      }
      if (this.disabled) {
        disable();
      }
    }

    MarkingSurface.prototype.zoom = function(zoomBy) {
      this.zoomBy = zoomBy != null ? zoomBy : 1;
      if (this.zoomBy < 1 + this.zoomSnapTolerance) {
        this.zoomBy = 1;
        this.panX = this.constructor.prototype.panX;
        this.panY = this.constructor.prototype.panY;
      }
      this.pan();
      return null;
    };

    MarkingSurface.prototype.pan = function(panX, panY) {
      var height, minX, minY, tool, width, _i, _len, _ref2;
      this.panX = panX != null ? panX : this.panX;
      this.panY = panY != null ? panY : this.panY;
      minX = (this.el.clientWidth - (this.el.clientWidth / this.zoomBy)) * this.panX;
      minY = (this.el.clientHeight - (this.el.clientHeight / this.zoomBy)) * this.panY;
      width = this.el.clientWidth / this.zoomBy;
      height = this.el.clientHeight / this.zoomBy;
      this.svg.attr('viewBox', "" + minX + " " + minY + " " + width + " " + height);
      _ref2 = this.tools;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        tool = _ref2[_i];
        tool.render();
      }
      return null;
    };

    MarkingSurface.prototype.onMouseMove = function(e) {
      var x, y, _ref2;
      if (this.zoomBy === 1) {
        return;
      }
      _ref2 = this.pointerOffset(e), x = _ref2.x, y = _ref2.y;
      this.pan(x / this.el.clientWidth, y / this.el.clientHeight);
      return null;
    };

    MarkingSurface.prototype.onTouchMove = function(e) {
      this.onMouseMove(e);
      return null;
    };

    MarkingSurface.prototype.onMouseDown = function(e) {
      var dragEvent, mark, releaseEvent, tool, _ref2,
        _this = this;
      if (this.disabled) {
        return;
      }
      if (e.defaultPrevented) {
        return;
      }
      if (_ref2 = e.target, __indexOf.call(this.el.querySelectorAll("." + ToolControls.prototype.className + ", ." + ToolControls.prototype.className + " *"), _ref2) >= 0) {
        return;
      }
      e.preventDefault();
      this.offsetAtLastMousedown = this.el.getBoundingClientRect();
      if ((this.selection == null) || this.selection.isComplete()) {
        if (this.tool != null) {
          tool = new this.tool({
            surface: this
          });
          mark = tool.mark;
          tool.on('select', function() {
            var _ref3;
            _this.el.focus();
            if (_this.selection === tool) {
              return;
            }
            if ((_ref3 = _this.selection) != null) {
              _ref3.deselect();
            }
            removeFrom(tool, _this.tools);
            _this.tools.push(tool);
            _this.selection = tool;
            return _this.trigger('select-tool', [_this.selection]);
          });
          tool.on('deselect', function() {
            return _this.selection = null;
          });
          tool.on('destroy', function() {
            removeFrom(tool, _this.tools);
            return _this.trigger('destroy-tool', [tool]);
          });
          this.tools.push(tool);
          this.trigger('create-tool', [tool]);
          mark.on('change', function() {
            return _this.trigger('change', [mark]);
          });
          mark.on('destroy', function() {
            removeFrom(mark, _this.marks);
            _this.trigger('destroy-mark', [mark]);
            return _this.trigger('change', [mark]);
          });
          this.marks.push(mark);
          this.trigger('create-mark', [mark]);
          this.trigger('change');
        }
      } else {
        tool = this.selection;
      }
      if (tool != null) {
        tool.select();
        tool.onInitialClick(e);
      }
      dragEvent = e.type === 'mousedown' ? 'mousemove' : 'touchmove';
      releaseEvent = e.type === 'mousedown' ? 'mouseup' : 'touchend';
      document.addEventListener(dragEvent, this.onDrag, false);
      document.addEventListener(releaseEvent, this.onRelease, false);
      return null;
    };

    MarkingSurface.prototype.onDrag = function(e) {
      var _ref2;
      e.preventDefault();
      if ((_ref2 = this.selection) != null) {
        _ref2.onInitialDrag.apply(_ref2, arguments);
      }
      return null;
    };

    MarkingSurface.prototype.onRelease = function(e) {
      var dragEvent, _ref2;
      e.preventDefault();
      dragEvent = e.type === 'mouseup' ? 'mousemove' : 'touchmove';
      document.removeEventListener(dragEvent, this.onDrag, false);
      document.removeEventListener(e.type, this.onRelease, false);
      if ((_ref2 = this.selection) != null) {
        _ref2.onInitialRelease.apply(_ref2, arguments);
      }
      return null;
    };

    MarkingSurface.prototype.onTouchStart = function(e) {
      if (e.touches.length === 1) {
        this.onMouseDown(e);
      }
      return null;
    };

    MarkingSurface.prototype.onKeyDown = function(e) {
      var current, next, _ref2, _ref3;
      if (this.disabled) {
        return;
      }
      if (e.altKey || e.ctrlKey) {
        return;
      }
      if (document.activeElement !== this.el) {
        return;
      }
      switch (e.which) {
        case BACKSPACE:
        case DELETE:
          e.preventDefault();
          if ((_ref2 = this.selection) != null) {
            _ref2.mark.destroy();
          }
          break;
        case TAB:
          e.preventDefault();
          if (e.shiftKey) {
            if ((_ref3 = this.tools[0]) != null) {
              _ref3.select();
            }
          } else {
            e.preventDefault();
            current = this.selection;
            next = this.tools[Math.max(0, this.tools.length - 2)];
            if (next != null) {
              next.select();
              removeFrom(current, this.tools);
              this.tools.unshift(current);
            }
          }
      }
      return null;
    };

    MarkingSurface.prototype.getValue = function() {
      return JSON.stringify(this.marks);
    };

    MarkingSurface.prototype.addShape = function() {
      var _ref2;
      return (_ref2 = this.svgRoot).addShape.apply(_ref2, arguments);
    };

    MarkingSurface.prototype.disable = function(e) {
      var _ref2;
      this.disabled = true;
      this.el.setAttribute('disabled', 'disabled');
      if ((_ref2 = this.selection) != null) {
        _ref2.deselect();
      }
      return null;
    };

    MarkingSurface.prototype.enable = function(e) {
      this.disabled = false;
      this.el.removeAttribute('disabled');
      return null;
    };

    MarkingSurface.prototype.reset = function() {
      var _results;
      _results = [];
      while (this.marks.length !== 0) {
        _results.push(this.marks[0].destroy());
      }
      return _results;
    };

    MarkingSurface.prototype.destroy = function() {
      this.reset();
      this.el.removeEventListener('mousedown', this.onMouseDown, false);
      this.el.removeEventListener('mousemove', this.onMouseMove, false);
      this.el.removeEventListener('touchstart', this.onTouchStart, false);
      this.el.removeEventListener('touchmove', this.onTouchMove, false);
      this.el.removeEventListener('keydown', this.onKeyDown, false);
      MarkingSurface.__super__.destroy.apply(this, arguments);
      return null;
    };

    MarkingSurface.prototype.pointerOffset = function(e) {
      var left, originalEvent, top, x, y, _ref2;
      if ('originalEvent' in e) {
        originalEvent = e.originalEvent;
      }
      if ((originalEvent != null) && 'touches' in originalEvent) {
        e = originalEvent.touches[0];
      }
      _ref2 = this.offsetAtLastMousedown || this.el.getBoundingClientRect(), left = _ref2.left, top = _ref2.top;
      x = e.pageX - pageXOffset - left;
      y = e.pageY - pageYOffset - top;
      return {
        x: x,
        y: y
      };
    };

    return MarkingSurface;

  })(BaseClass);

  MarkingSurface.defaultStyle = insertStyle('marking-surface-default-style', '.marking-surface-style-container {\n  display: none;\n}\n\n.marking-surface {\n  display: inline-block;\n  position: relative;\n}\n\n.marking-surface > svg {\n  display: block;\n  height: 100%;\n  width: 100%;\n}');

  MarkingSurface.BaseClass = BaseClass;

  MarkingSurface.SVG = SVG;

  MarkingSurface.Mark = Mark;

  MarkingSurface.ToolControls = ToolControls;

  MarkingSurface.Tool = Tool;

  if (typeof window !== "undefined" && window !== null) {
    window.MarkingSurface = MarkingSurface;
  }

  if (typeof module !== "undefined" && module !== null) {
    module.exports = MarkingSurface;
  }

}).call(this);

/*
//@ sourceMappingURL=marking-surface.map
*/
